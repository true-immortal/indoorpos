<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indoor Navigation System</title>
    <style>
        #map {
            width: 100%;
            height: 600px;
            border: 1px solid #000;
            position: relative;
            background: url('your-floorplan-image.jpg') no-repeat center center;
            background-size: cover;
            overflow: hidden;
        }
        .marker {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: red;
            border-radius: 50%;
        }
        #debug {
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Indoor Navigation System</h1>
    <div id="map"></div>
    <button id="startTracking">Start Tracking</button>
    <button id="stopTracking">Stop Tracking</button>
    <button id="calibrate">Calibrate</button>
    <div id="debug"></div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            let tracking = false;
            let calibrating = false;
            let calibrationOffsets = { accX: 0, accY: 0, accZ: 0 };
            let lastPosition = { x: 100, y: 100 }; // Initial position
            let prevAcceleration = { x: 0, y: 0 };
            let prevTime = Date.now();
            const map = document.getElementById('map');
            const mapWidth = map.offsetWidth;
            const mapHeight = map.offsetHeight;

            const movementThreshold = 0.2; // Minimum movement to consider as significant
            const alpha = 0.2; // Smoothing factor for low-pass filter

            // Low-pass filter for smoothing
            const lowPassFilter = (value, previousValue) => {
                return alpha * value + (1 - alpha) * previousValue;
            };

            const updatePosition = (x, y) => {
                const marker = document.createElement('div');
                marker.className = 'marker';
                marker.style.left = `${x}px`;
                marker.style.top = `${y}px`;
                map.appendChild(marker);
            };

            const handleDeviceMotion = (event) => {
                if (!tracking) return;

                const acceleration = event.accelerationIncludingGravity;
                const currentTime = Date.now();
                const deltaTime = (currentTime - prevTime) / 1000; // Time in seconds

                // Apply calibration offsets
                const accX = acceleration.x - calibrationOffsets.accX;
                const accY = acceleration.y - calibrationOffsets.accY;

                // Apply low-pass filter to smooth data
                const filteredAccX = lowPassFilter(accX, prevAcceleration.x);
                const filteredAccY = lowPassFilter(accY, prevAcceleration.y);

                // Invert X and Y axes to switch left and right directions
                const movementX = -filteredAccX * deltaTime * 10; // Move left/right based on acceleration
                const movementY = filteredAccY * deltaTime * 10; // Move up/down based on acceleration

                // Update position only if significant movement detected
                if (Math.abs(movementX) > movementThreshold || Math.abs(movementY) > movementThreshold) {
                    lastPosition.x += movementX;
                    lastPosition.y += movementY;

                    // Boundary handling
                    if (lastPosition.x < 0) lastPosition.x = 0;
                    if (lastPosition.x > mapWidth) lastPosition.x = mapWidth;
                    if (lastPosition.y < 0) lastPosition.y = 0;
                    if (lastPosition.y > mapHeight) lastPosition.y = mapHeight;

                    // Update marker position on map
                    updatePosition(lastPosition.x, lastPosition.y);
                }

                // Update previous values
                prevAcceleration.x = filteredAccX;
                prevAcceleration.y = filteredAccY;
                prevTime = currentTime;

                // Debugging output
                document.getElementById('debug').innerHTML = `
                    Acceleration: X: ${filteredAccX.toFixed(2)}, Y: ${filteredAccY.toFixed(2)}<br>
                    Position: X: ${lastPosition.x.toFixed(2)}, Y: ${lastPosition.y.toFixed(2)}
                `;
            };

            const calibrate = () => {
                calibrating = true;
                const accXReadings = [];
                const accYReadings = [];
                const accZReadings = [];
                const numReadings = 100; // Number of readings for calibration

                const calibrationInterval = setInterval(() => {
                    if (accXReadings.length >= numReadings) {
                        clearInterval(calibrationInterval);
                        calibrationOffsets.accX = accXReadings.reduce((a, b) => a + b) / numReadings;
                        calibrationOffsets.accY = accYReadings.reduce((a, b) => a + b) / numReadings;
                        calibrationOffsets.accZ = accZReadings.reduce((a, b) => a + b) / numReadings;
                        calibrating = false;
                        document.getElementById('debug').innerHTML += '<br>Calibration complete!';
                        return;
                    }
                    // Accumulate readings
                    window.addEventListener('devicemotion', (event) => {
                        if (calibrating) {
                            accXReadings.push(event.accelerationIncludingGravity.x);
                            accYReadings.push(event.accelerationIncludingGravity.y);
                            accZReadings.push(event.accelerationIncludingGravity.z);
                        }
                    });
                }, 100); // Collect data every 100 ms
            };

            window.addEventListener('devicemotion', handleDeviceMotion);

            document.getElementById('startTracking').addEventListener('click', () => {
                tracking = true;
                lastPosition = { x: 100, y: 100 }; // Reset position on start
                document.getElementById('map').innerHTML = ''; // Clear previous path
            });

            document.getElementById('stopTracking').addEventListener('click', () => {
                tracking = false;
            });

            document.getElementById('calibrate').addEventListener('click', () => {
                calibrate();
            });

            // Ensure correct initialization of position on page load
            updatePosition(lastPosition.x, lastPosition.y);
        });
    </script>
</body>
</html>
